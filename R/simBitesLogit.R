#' simBitesLogit: Generates a bite dataset by randomly sampling time
#'
#' This function generates a bite dataset from meal duration, number of bites, and total intake (Emax) by randomly sampling a logistic distrubtion truncated to only include positive values
#'
#' @param mealdur Meal duration in minutes
#' @inheritParams simBites
#' @inheritParams simBites
#' @param id (optional) ID number, if exists will be added to output_dat. Default is no id.
#' @inheritParams simBites
#'
#'
#' @return A bite dataset generated by randomly sampling time
#'
#' @examples
#'
#' \dontrun{
#' }
#'
#'
#' @export

simBitesLogit = function(mealdur, nBites, Emax, id){

  lengthEqual <- all(sapply(list(length(mealdur),length(nBites),length(Emax),length(id)), function(x) x == length(id)))

  if (isTRUE(lengthEqual)){
    data <- data.frame(id, mealdur, nBites, Emax)
  } else {
    stop('All entered vectors must have the same length')
  }

  for(p in 1:nrow(data)){
    #get randomly generated values from logistic distribution
    randlogistic <- round(sort(truncdist::rtrunc(data[p, 'nBites'], spec = 'logis', a = 0, location = 0, scale = 7)))
    rand_time <- (randlogistic/max(randlogistic))*data[p, 'mealdur']
    sampled_time <- jitter(rand_time, factor = 2)

    #sort so in order from earlier to later
    sampled_time <- sort(sampled_time)

    #make sure the jitter didn't extend the meal duraiton
    nTimePoints <- data[p, 'nBites']
    if(sampled_time[nTimePoints] > data[p, 'mealdur']){
      sampled_time[nTimePoints] <- data[p, 'mealdur']

      #if second to last timepoint > meal dur, set to half way between third to last and last
      if (sampled_time[nTimePoints] < sampled_time[nTimePoints-1]){
        sampled_time[nTimePoints-1] <- (sampled_time[nTimePoints] - sampled_time[nTimePoints-2])/2
      }
    }

    #make sure starting value is 0 or greater for first bite
    nNeg <- sum(sampled_time < 0)

    if(nNeg > 0){
      for (b in 1:length(sampled_time)){
        if (sampled_time[b] < 0){
          if (b == 1){
            sampled_time[1] <- 0
          } else {
            #check to see if previous value is greater than future values
            checkDecrease <- data.frame(decrease = sampled_time[b-1] > sampled_time, b = seq(1, length(sampled_time)))

            #if more than current value is less than previous
            if (sum(checkDecrease$decrease[b:nrow(checkDecrease)]) > 1){
              next_b <- max(checkDecrease[checkDecrease$decrease == TRUE, ]$b) + 1
              nsteps <- sum(checkDecrease$decrease) + 1
            } else {
              next_b <- b + 1
              nsteps <- 2
            }

            sampled_time[b] <-  sampled_time[b-1] + (sampled_time[next_b] - sampled_time[b-1])/nsteps
          }
        }
      }
    }

    #get bite numbers
    bites <- seq(1, data[p, 'nBites'], by = 1)

    #get cummulative intake
    grams.bite_avg <- rep(data[p, 'Emax'] /data[p, 'nBites'], data[p, 'nBites'])
    grams.cumulative_avg <- cumsum(grams.bite_avg)

    id_arg <- methods::hasArg(id)
    if(isTRUE(id_arg)){
      sim_dat <- data.frame(rep(data[p, 'id'], data[p, 'nBites']), bites, sampled_time, grams.cumulative_avg)
      names(sim_dat) <- c('id', 'Bite', 'Time', 'CumulativeGrams_avgBite')
    } else {
      sim_dat <- data.frame(bites, sampled_time, grams.cumulative_avg)
      names(sim_dat) <- c('Bite', 'Time', 'CumulativeGrams_avgBite')
    }

    if (p == 1){
      sim_dat_long <- sim_dat
    } else {
      sim_dat_long <- rbind(sim_dat_long, sim_dat)
    }

  }
  #set up output_dat
  return(sim_dat_long)
}
