#' simBitesQuad: Generates a bite dataset by randomly sampling time from a truncated quadratic distribution
#'
#' This function generates a bite dataset from meal duration, number of bites, and total intake (Emax) by randomly sampling a quadratic distribution truncated to only include positive values
#'
#' @param mealdur Meal duration in minutes
#' @inheritParams genBiteDat
#' @inheritParams genBiteDat
#' @inheritParams genBiteDat
#'
#' @return A bite dataset generated by randomly sampling time
#'
#' @examples
#'
#' \dontrun{
#' }
#'
#'
#' @export

simBitesQuad <- function(mealdur, nBites, Emax, id) {

  # ensure all entered vectors have the same length
  if (hasArg('id')){
    lengthEqual <- all(sapply(list(length(mealdur), length(nBites), length(Emax), length(id)), function(x) x == length(id)))
  } else {
    lengthEqual <- all(sapply(list(length(mealdur), length(nBites), length(Emax)), function(x) x == length(Emax)))
  }

  if (isTRUE(lengthEqual)) {
    data <- data.frame(id, mealdur, nBites, Emax)
  } else {
    stop("All entered vectors must have the same length")
  }

  # loop through provided data to generate bite data
  for (p in 1:nrow(data)) {
    # get randomly generated values from quadratic distribution

    # HERE

    rand_time <- (randquad / max(randquad)) * data[p, "mealdur"]
    sampled_time <- jitter(rand_time, factor = 2)

    # sort so in order from earlier to later
    sampled_time <- sort(sampled_time)

    # make sure the jitter didn't extend the meal duration
    nTimePoints <- data[p, "nBites"]
    if (sampled_time[nTimePoints] > data[p, "mealdur"]) {
      sampled_time[nTimePoints] <- data[p, "mealdur"]

      # if second to last timepoint > meal dur, set to half way between third to last and last
      if (sampled_time[nTimePoints] < sampled_time[nTimePoints - 1]) {
        sampled_time[nTimePoints - 1] <- (sampled_time[nTimePoints] - sampled_time[nTimePoints - 2]) / 2
      }
    }

    # make sure starting value is 0 or greater for first bite
    nNeg <- sum(sampled_time < 0)

    if (nNeg > 0) {
      for (b in 1:length(sampled_time)) {
        if (sampled_time[b] < 0) {
          if (b == 1) {
            sampled_time[1] <- 0
          } else {
            # check to see if previous value is greater than future values
            checkDecrease <- data.frame(decrease = sampled_time[b - 1] > sampled_time, b = seq(1, length(sampled_time)))

            # if more than current value is less than previous
            if (sum(checkDecrease$decrease[b:nrow(checkDecrease)]) > 1) {
              next_b <- max(checkDecrease[checkDecrease$decrease == TRUE, ]$b) + 1
              nsteps <- sum(checkDecrease$decrease) + 1
            } else {
              next_b <- b + 1
              nsteps <- 2
            }

            sampled_time[b] <- sampled_time[b - 1] + (sampled_time[next_b] - sampled_time[b - 1]) / nsteps
          }
        }
      }
    }

    # get bite numbers
    bites <- seq(1, data[p, "nBites"], by = 1)

    # get cummulative intake
    grams.bite_avg <- rep(data[p, "Emax"] / data[p, "nBites"], data[p, "nBites"])
    grams.cumulative_avg <- cumsum(grams.bite_avg)

    id_arg <- methods::hasArg(id)
    if (isTRUE(id_arg)) {
      sim_dat <- data.frame(rep(data[p, "id"], data[p, "nBites"]), bites, sampled_time, grams.cumulative_avg)
      names(sim_dat) <- c("id", "Bite", "Time", "CumulativeGrams_avgBite")
    } else {
      sim_dat <- data.frame(bites, sampled_time, grams.cumulative_avg)
      names(sim_dat) <- c("Bite", "Time", "CumulativeGrams_avgBite")
    }

    if (p == 1) {
      sim_dat_long <- sim_dat
    } else {
      sim_dat_long <- rbind(sim_dat_long, sim_dat)
    }
  }
  # set up output_dat
  return(sim_dat_long)
}
